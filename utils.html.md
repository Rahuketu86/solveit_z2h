# utils


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

``` python
class Value:
    def __init__(self, data): store_attr('data', self)
    __repr__=basic_repr('data')
```

``` python
Value(data=1)
```

    Value(data=1)

``` python
a = Value(2.0)
b = Value(-3.0)
```

``` python
from fastcore.utils import patch, patch_to
```

``` python
@patch_to(Value)
def __mul__(self:Value, other): return Value(self.data*other.data)
```

``` python
a = Value(2.0)
b = Value(-3.0)
a*b
```

    Value(data=-6.0, grad=0.0, _op='', _prev=set())

``` python
class Value:
    def __init__(self, data, children=(), op=''): 
        store_attr('data', self) # Largely overkill but want to try how fastcore works
        self._prev = set(children)
        self._op = op
        self.grad = 0.0
    __repr__= basic_repr('data, grad, _op, _prev')
```

``` python
@patch_to(Value)
def __add__(self:Value, other): return Value(self.data+other.data, children=(self, other), op="+")

@patch_to(Value)
def __mul__(self:Value, other): return Value(self.data*other.data, children=(self, other), op="*")
```

``` python
a = Value(2.0)
b = Value(-3.0)
a*b, a+b
```

    (Value(data=-6.0, grad=0.0, _op='*', _prev={Value(data=2.0, grad=0.0, _op='', _prev=set()), Value(data=-3.0, grad=0.0, _op='', _prev=set())}),
     Value(data=-1.0, grad=0.0, _op='+', _prev={Value(data=2.0, grad=0.0, _op='', _prev=set()), Value(data=-3.0, grad=0.0, _op='', _prev=set())}))

## Plan

- I need a good way to visualize the computational graph in solveit.
  Earlier I used graphviz but it‚Äôs not possible in solve it. I am
  thinking I may use `render_ft` and svg functionality but I am open to
  other suggestions.
- Earlier code

<!-- -->

    # %% ../nbs/01_utils.ipynb 3
    import numpy as np
    import scipy as sp
    import matplotlib.pyplot as plt 
    # import graphviz
    from graphviz import Digraph
    from .core import Value


    # %% ../nbs/01_utils.ipynb 11
    def trace(root):
        nodes, edges = set(), set()
        def build(v):
            if v: nodes.add(v)
            for i in v._prev:
                nodes.add(i)
                edges.add((i, v))
                build(i)
        build(root)
        return nodes, edges

    # %% ../nbs/01_utils.ipynb 14
    def draw_dot(root):
        dot = Digraph(format="svg", graph_attr={"rankdir":'LR'})
        nodes, edges = trace(root)
        for n in nodes:
            # print(str(id(n)))
            uid = str(id(n))
            dot.node(uid, label=f" {{ {n.label}|{n.data:.4f}| grad: {n.grad:.4f}  }}", shape='record') # For { in f-string use {{
            if n._op:
                dot.node(uid+n._op, n._op)
                dot.edge(uid+n._op, uid)
        for n1, n2 in edges:
            dot.edge(str(id(n1)), str(id(n2))+n2._op)
            
        return dot

Help me get started

##### ü§ñReplyü§ñ<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

I can help you visualize your computational graph in solveit! Since
graphviz rendering won‚Äôt work here, let‚Äôs explore some alternatives.

A few options:

1.  **matplotlib with networkx** - Draw the graph using matplotlib
    (which works in solveit). This would give you a visual diagram
    similar to graphviz.

2.  **ASCII/text representation** - Create a simple text-based tree view
    that shows the computation structure.

3.  **HTML/SVG with custom rendering** - Build SVG elements manually and
    display them.

Which approach interests you most? Or would you like me to show you a
quick example of one of them (I‚Äôd suggest starting with
matplotlib+networkx since those libraries are already available)?

Ok let‚Äôs try first with networkx

##### ü§ñReplyü§ñ<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

Great choice! Let‚Äôs start by creating a simple visualization of your
computational graph using matplotlib and networkx.

First, let‚Äôs adapt your
[`trace`](https://Rahuketu86.github.io/solveit_z2h/utils.html#trace)
function to work with your current `Value` class, then create a basic
graph visualization:

``` python
def trace(root):
    nodes, edges = set(), set()
    def build(v):
        if v: nodes.add(v)
        for child in v._prev:
            edges.add((child, v))
            build(child)
    build(root)
    return nodes, edges
```

Try running this with one of your existing expressions (like `a*b` or
the more complex ones). Once you have that working, we can add the
networkx visualization part.

What would you like to visualize first?

------------------------------------------------------------------------

<a
href="https://github.com/Rahuketu86/solveit_z2h/blob/main/solveit_z2h/utils.py#L19"
target="_blank" style="float:right; font-size:smaller">source</a>

### trace

>  trace (root)

``` python
import networkx as nx

def draw_graph(root):
    nodes, edges = trace(root)
    G = nx.DiGraph()
    
    for n in nodes:
        label = f"{n._op if n._op else 'val'}\n{n.data:.2f}"
        G.add_node(id(n), label=label)
    
    for n1, n2 in edges:
        G.add_edge(id(n1), id(n2))
    
    pos = nx.spring_layout(G)
    labels = nx.get_node_attributes(G, 'label')
    
    plt.figure(figsize=(10, 6))
    nx.draw(G, pos, labels=labels, node_color='lightblue', 
            node_size=2000, arrows=True, arrowsize=20)
    plt.show()
```

``` python
c = a*b+ a+b
draw_graph(c)
```

![](02_utils_files/figure-commonmark/cell-13-output-1.png)

I want to build something like this
![pasted_image_eb8cd16a-0e91-4c6d-8921-94ca6886d812.png](02_utils_files/figure-commonmark/f6407b4b-1-eb8cd16a-0e91-4c6d-8921-94ca6886d812.png)

##### ü§ñReplyü§ñ<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

Nice! That‚Äôs a much cleaner layout than what we have now. I can see a
few key differences from your current visualization:

1.  **Left-to-right flow** (like a proper computational graph)
2.  **Separate nodes for operations** (the circles with `*` and `+`)
3.  **Rectangular boxes for values** showing the label, data, and grad
4.  **Hierarchical layout** instead of spring layout

The main changes needed are: - Use a hierarchical layout (like
`nx.planar_layout` or manually position nodes by layer) - Create
separate nodes for operations (not just the Value nodes) - Draw
rectangles for values and circles for operations - Add the labels with
data and grad information

Would you like to tackle this step-by-step, or would you prefer me to
write the complete function for you?

Please write the code for me

##### ü§ñReplyü§ñ<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

Here‚Äôs a complete function to create that style of visualization:

``` python
def draw_graph(root):
    nodes, edges = trace(root)
    G = nx.DiGraph()
    
    # Add nodes for values and operations
    for n in nodes:
        uid = id(n)
        G.add_node(uid, type='value', value=n)
        if n._op:
            op_uid = f"{uid}_op"
            G.add_node(op_uid, type='op', op=n._op)
            G.add_edge(op_uid, uid)
    
    # Add edges from children to operations
    for n1, n2 in edges:
        if n2._op:
            G.add_edge(id(n1), f"{id(n2)}_op")
    
    # Use hierarchical layout
    pos = nx.spring_layout(G, k=2, iterations=50)
    
    fig, ax = plt.subplots(figsize=(12, 6))
    
    # Draw operation nodes (circles)
    op_nodes = [n for n, d in G.nodes(data=True) if d.get('type') == 'op']
    nx.draw_networkx_nodes(G, pos, nodelist=op_nodes, node_shape='o', 
                          node_color='white', edgecolors='black', 
                          node_size=800, ax=ax)
    for node in op_nodes:
        op = G.nodes[node]['op']
        x, y = pos[node]
        ax.text(x, y, op, ha='center', va='center', fontsize=12)
    
    # Draw value nodes (rectangles)
    val_nodes = [n for n, d in G.nodes(data=True) if d.get('type') == 'value']
    for node in val_nodes:
        v = G.nodes[node]['value']
        x, y = pos[node]
        label = getattr(v, 'label', 'val')
        rect = plt.Rectangle((x-0.08, y-0.04), 0.16, 0.08, 
                             facecolor='white', edgecolor='black')
        ax.add_patch(rect)
        ax.text(x, y+0.015, f"{label}", ha='center', va='center', fontsize=9)
        ax.text(x, y-0.015, f"{v.data:.4f} | grad: {v.grad:.4f}", 
               ha='center', va='center', fontsize=7)
    
    # Draw edges
    nx.draw_networkx_edges(G, pos, edge_color='black', 
                          arrows=True, arrowsize=15, ax=ax)
    
    ax.set_xlim(min(x for x, y in pos.values())-0.2, 
                max(x for x, y in pos.values())+0.2)
    ax.set_ylim(min(y for x, y in pos.values())-0.2, 
                max(y for x, y in pos.values())+0.2)
    ax.axis('off')
    plt.tight_layout()
    plt.show()
```

You‚Äôll notice your `Value` class needs a `label` attribute for the node
names (like ‚Äòa‚Äô, ‚Äòb‚Äô, ‚Äòc‚Äô). Try adding that to your `__init__` method
and then test it with your expression!

``` python
def draw_graph(root):
    nodes, edges = trace(root)
    G = nx.DiGraph()
    
    # Add nodes for values and operations
    for n in nodes:
        uid = id(n)
        G.add_node(uid, type='value', value=n)
        if n._op:
            op_uid = f"{uid}_op"
            G.add_node(op_uid, type='op', op=n._op)
            G.add_edge(op_uid, uid)
    
    # Add edges from children to operations
    for n1, n2 in edges:
        if n2._op:
            G.add_edge(id(n1), f"{id(n2)}_op")
    
    # Use hierarchical layout
    pos = nx.spring_layout(G, k=2, iterations=50)
    
    fig, ax = plt.subplots(figsize=(12, 6))
    
    # Draw operation nodes (circles)
    op_nodes = [n for n, d in G.nodes(data=True) if d.get('type') == 'op']
    nx.draw_networkx_nodes(G, pos, nodelist=op_nodes, node_shape='o', 
                          node_color='white', edgecolors='black', 
                          node_size=800, ax=ax)
    for node in op_nodes:
        op = G.nodes[node]['op']
        x, y = pos[node]
        ax.text(x, y, op, ha='center', va='center', fontsize=12)
    
    # Draw value nodes (rectangles)
    val_nodes = [n for n, d in G.nodes(data=True) if d.get('type') == 'value']
    for node in val_nodes:
        v = G.nodes[node]['value']
        x, y = pos[node]
        label = getattr(v, 'label', 'val')
        rect = plt.Rectangle((x-0.08, y-0.04), 0.16, 0.08, 
                             facecolor='white', edgecolor='black')
        ax.add_patch(rect)
        ax.text(x, y+0.015, f"{label}", ha='center', va='center', fontsize=9)
        ax.text(x, y-0.015, f"{v.data:.4f} | grad: {v.grad:.4f}", 
               ha='center', va='center', fontsize=7)
    
    # Draw edges
    nx.draw_networkx_edges(G, pos, edge_color='black', 
                          arrows=True, arrowsize=15, ax=ax)
    
    ax.set_xlim(min(x for x, y in pos.values())-0.2, 
                max(x for x, y in pos.values())+0.2)
    ax.set_ylim(min(y for x, y in pos.values())-0.2, 
                max(y for x, y in pos.values())+0.2)
    ax.axis('off')
    plt.tight_layout()
    plt.show()
```

``` python
draw_graph(c)
```

![](02_utils_files/figure-commonmark/cell-15-output-1.png)

I think I should construct something manually

##### ü§ñReplyü§ñ<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

Good instinct! The spring layout is giving you a messy arrangement. For
a clean left-to-right computational graph like your reference image,
you‚Äôll want to manually position nodes by their ‚Äúdepth‚Äù in the
computation.

The key idea is to assign each node a layer number (leaf nodes are layer
0, nodes that depend on them are layer 1, etc.), then position them
based on that.

Would you like to: 1. Write a function to compute the layer/depth for
each node 2. Use networkx‚Äôs built-in hierarchical layout options (like
`multipartite_layout`) 3. Something else?

Which approach sounds more interesting to you?

Should we try with svg ? Is there a way to use graphviz style digraph?

##### ü§ñReplyü§ñ<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

Yes, you can use graphviz directly! The `graphviz` library is already
installed in your solveit instance. It can generate SVG output that will
display nicely.

The approach would be very similar to your old code - create a `Digraph`
object, add nodes and edges, and then display it. In solveit, you can
render it as SVG.

Would you like to adapt your old
[`draw_dot`](https://Rahuketu86.github.io/solveit_z2h/utils.html#draw_dot)
function to work with your current `Value` class? It should be pretty
straightforward since you already have the basic structure.

------------------------------------------------------------------------

<a
href="https://github.com/Rahuketu86/solveit_z2h/blob/main/solveit_z2h/utils.py#L34"
target="_blank" style="float:right; font-size:smaller">source</a>

### draw_dot

>  draw_dot (root)

``` python
draw_dot(c)
```

    AttributeError: 'Value' object has no attribute 'label'
    [31m---------------------------------------------------------------------------[39m
    [31mAttributeError[39m                            Traceback (most recent call last)
    [36mCell[39m[36m [39m[32mIn[1][39m[32m, line 1[39m
    [32m----> [39m[32m1[39m [43mdraw_dot[49m[43m([49m[43mc[49m[43m)[49m

    [36mCell[39m[36m [39m[32mIn[1][39m[32m, line 7[39m, in [36mdraw_dot[39m[34m(root)[39m
    [32m      4[39m [38;5;28;01mfor[39;00m n [38;5;129;01min[39;00m nodes:
    [32m      5[39m     [38;5;66;03m# print(str(id(n)))[39;00m
    [32m      6[39m     uid = [38;5;28mstr[39m([38;5;28mid[39m(n))
    [32m----> [39m[32m7[39m     dot.node(uid, label=[33mf[39m[33m"[39m[33m [39m[38;5;130;01m{{[39;00m[33m [39m[38;5;132;01m{[39;00m[43mn[49m[43m.[49m[43mlabel[49m[38;5;132;01m}[39;00m[33m|[39m[38;5;132;01m{[39;00mn.data[38;5;132;01m:[39;00m[33m.4f[39m[38;5;132;01m}[39;00m[33m| grad: [39m[38;5;132;01m{[39;00mn.grad[38;5;132;01m:[39;00m[33m.4f[39m[38;5;132;01m}[39;00m[33m  [39m[38;5;130;01m}}[39;00m[33m"[39m, shape=[33m'[39m[33mrecord[39m[33m'[39m) [38;5;66;03m# For { in f-string use {{[39;00m
    [32m      8[39m     [38;5;28;01mif[39;00m n._op:
    [32m      9[39m         dot.node(uid+n._op, n._op)

    [31mAttributeError[39m: 'Value' object has no attribute 'label'

How to get label from variable name?

##### ü§ñReplyü§ñ<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

You need to add a `label` attribute to your `Value` class. The tricky
part is that Python doesn‚Äôt automatically know what variable name you
assigned to an object.

You have a few options:

1.  **Pass the label explicitly** when creating a `Value`:

    ``` python
    a = Value(2.0, label='a')
    ```

2.  **Use a default label** (like ‚Äòval‚Äô) and only set it when you need
    it:

    ``` python
    a = Value(2.0)
    a.label = 'a'
    ```

3.  **Modify
    [`draw_dot`](https://Rahuketu86.github.io/solveit_z2h/utils.html#draw_dot)**
    to use a fallback when there‚Äôs no label (like you did with `getattr`
    in the matplotlib version)

Which approach would you prefer? The first option is cleanest if you‚Äôre
okay with adding labels when you create values.

Can it auto assign if label not provided?

##### ü§ñReplyü§ñ<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

Yes! You can make the label optional and auto-generate one if not
provided. Here‚Äôs how you could modify your `Value.__init__`:

``` python
def __init__(self, data, children=(), op='', label=None): 
    store_attr('data', self)
    self._prev = set(children)
    self._op = op
    self.grad = 0.0
    self.label = label if label is not None else ''
```

This way, if you don‚Äôt provide a label, it defaults to an empty string.
Then in
[`draw_dot`](https://Rahuketu86.github.io/solveit_z2h/utils.html#draw_dot),
you could display the empty string or show something like the operation
or just the data.

Does this approach work for what you need?

``` python
class Value:
    def __init__(self, data, children=(), op='', label=None): 
        store_attr('data', self) # Largely overkill but want to try how fastcore works
        self._prev = set(children)
        self._op = op
        self.grad = 0.0
        self.label = label if label is not None else ''
    __repr__= basic_repr('data, grad, _op, _prev, label')

@patch_to(Value)
def __add__(self:Value, other): return Value(self.data+other.data, children=(self, other), op="+")

@patch_to(Value)
def __mul__(self:Value, other): return Value(self.data*other.data, children=(self, other), op="*")
```

``` python
a = Value(2.0)
b = Value(-3.0)
a*b, a+b
c = a*b+a+b; c
```

    Value(data=-7.0, grad=0.0, _op='+', _prev={Value(data=-4.0, grad=0.0, _op='+', _prev={Value(data=2.0, grad=0.0, _op='', _prev=set(), label=''), Value(data=-6.0, grad=0.0, _op='*', _prev={Value(data=2.0, grad=0.0, _op='', _prev=set(), label=''), Value(data=-3.0, grad=0.0, _op='', _prev=set(), label='')}, label='')}, label=''), Value(data=-3.0, grad=0.0, _op='', _prev=set(), label='')}, label='')

``` python
draw_dot(c)
```

![](02_utils_files/figure-commonmark/cell-20-output-1.svg)

``` python
@patch_to(Value)
def __repr_html__(self:Value): return draw_dot(self)
```

``` python
c.render()
```

![](02_utils_files/figure-commonmark/cell-22-output-1.svg)

``` python
c
```

    /usr/local/lib/python3.12/site-packages/IPython/core/formatters.py:429: FormatterWarning: text/html formatter returned invalid type <class 'graphviz.graphs.Digraph'> (expected <class 'str'>) for object: Value(data=-7.0, grad=0.0, _op='+', _prev={Value(data=-4.0, grad=0.0, _op='+', _prev={Value(data=2.0, grad=0.0, _op='', _prev=set(), label=''), Value(data=-6.0, grad=0.0, _op='*', _prev={Value(data=2.0, grad=0.0, _op='', _prev=set(), label=''), Value(data=-3.0, grad=0.0, _op='', _prev=set(), label='')}, label='')}, label=''), Value(data=-3.0, grad=0.0, _op='', _prev=set(), label='')}, label='')
      warnings.warn(

    Value(data=-7.0, grad=0.0, _op='+', _prev={Value(data=-4.0, grad=0.0, _op='+', _prev={Value(data=2.0, grad=0.0, _op='', _prev=set(), label=''), Value(data=-6.0, grad=0.0, _op='*', _prev={Value(data=2.0, grad=0.0, _op='', _prev=set(), label=''), Value(data=-3.0, grad=0.0, _op='', _prev=set(), label='')}, label='')}, label=''), Value(data=-3.0, grad=0.0, _op='', _prev=set(), label='')}, label='')

Can I make it part of default rendering in notebook

##### ü§ñReplyü§ñ<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

Yes! The `__repr_html__` method you added is the right approach for
Jupyter/IPython rendering. The issue is it needs to return a string
(HTML or SVG), not a Digraph object.

Try this instead:

``` python
@patch_to(Value)
def __repr_html__(self:Value): 
    return draw_dot(self)._repr_svg_()
```

The `_repr_svg_()` method on the Digraph object returns the actual SVG
string that Jupyter can display.

Test it by just typing `c` in a cell!

``` python
@patch_to(Value)
def __repr_html__(self:Value): return draw_dot(self)._repr_svg_()
```

``` python
c
```

    Value(data=-7.0, grad=0.0, _op='+', _prev={Value(data=-4.0, grad=0.0, _op='+', _prev={Value(data=2.0, grad=0.0, _op='', _prev=set(), label=''), Value(data=-6.0, grad=0.0, _op='*', _prev={Value(data=2.0, grad=0.0, _op='', _prev=set(), label=''), Value(data=-3.0, grad=0.0, _op='', _prev=set(), label='')}, label='')}, label=''), Value(data=-3.0, grad=0.0, _op='', _prev=set(), label='')}, label='')

``` python
a = Value(2.0)
b = Value(-3.0)
a*b, a+b
c = a*b+a+b; c
```

    /usr/local/lib/python3.12/site-packages/IPython/core/formatters.py:429: FormatterWarning: text/html formatter returned invalid type <class 'graphviz.graphs.Digraph'> (expected <class 'str'>) for object: Value(data=-7.0, grad=0.0, _op='+', _prev={Value(data=-3.0, grad=0.0, _op='', _prev=set(), label=''), Value(data=-4.0, grad=0.0, _op='+', _prev={Value(data=-6.0, grad=0.0, _op='*', _prev={Value(data=2.0, grad=0.0, _op='', _prev=set(), label=''), Value(data=-3.0, grad=0.0, _op='', _prev=set(), label='')}, label=''), Value(data=2.0, grad=0.0, _op='', _prev=set(), label='')}, label='')}, label='')
      warnings.warn(

    Value(data=-7.0, grad=0.0, _op='+', _prev={Value(data=-3.0, grad=0.0, _op='', _prev=set(), label=''), Value(data=-4.0, grad=0.0, _op='+', _prev={Value(data=-6.0, grad=0.0, _op='*', _prev={Value(data=2.0, grad=0.0, _op='', _prev=set(), label=''), Value(data=-3.0, grad=0.0, _op='', _prev=set(), label='')}, label=''), Value(data=2.0, grad=0.0, _op='', _prev=set(), label='')}, label='')}, label='')

It‚Äôs not rendering in solveit what to do ?

##### ü§ñReplyü§ñ<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

The issue is that `_repr_svg_()` returns the SVG as a string, but
solveit might need it wrapped in HTML. Try this:

``` python
@patch_to(Value)
def __repr_html__(self:Value): 
    return draw_dot(self)._repr_image_svg_xml()
```

Or alternatively:

``` python
@patch_to(Value)
def _repr_svg_(self:Value): 
    return draw_dot(self)._repr_svg_()
```

The second option uses `_repr_svg_` instead of `__repr_html__`. Try both
and see which one works in solveit!

``` python
@patch_to(Value)
def __repr_html__(self:Value): 
    return draw_dot(self)._repr_image_svg_xml()
```

``` python
a = Value(2.0)
b = Value(-3.0)
a*b, a+b
c = a*b+a+b; c
```

    /usr/local/lib/python3.12/site-packages/IPython/core/formatters.py:429: FormatterWarning: text/html formatter returned invalid type <class 'graphviz.graphs.Digraph'> (expected <class 'str'>) for object: Value(data=-7.0, grad=0.0, _op='+', _prev={Value(data=-3.0, grad=0.0, _op='', _prev=set(), label=''), Value(data=-4.0, grad=0.0, _op='+', _prev={Value(data=-6.0, grad=0.0, _op='*', _prev={Value(data=-3.0, grad=0.0, _op='', _prev=set(), label=''), Value(data=2.0, grad=0.0, _op='', _prev=set(), label='')}, label=''), Value(data=2.0, grad=0.0, _op='', _prev=set(), label='')}, label='')}, label='')
      warnings.warn(

    Value(data=-7.0, grad=0.0, _op='+', _prev={Value(data=-3.0, grad=0.0, _op='', _prev=set(), label=''), Value(data=-4.0, grad=0.0, _op='+', _prev={Value(data=-6.0, grad=0.0, _op='*', _prev={Value(data=-3.0, grad=0.0, _op='', _prev=set(), label=''), Value(data=2.0, grad=0.0, _op='', _prev=set(), label='')}, label=''), Value(data=2.0, grad=0.0, _op='', _prev=set(), label='')}, label='')}, label='')

``` python
@patch_to(Value)
def _repr_svg_(self:Value): 
    return draw_dot(self)._repr_svg_()
```

``` python
a = Value(2.0)
b = Value(-3.0)
a*b, a+b
c = a*b+a+b; c
```

    AttributeError: 'Digraph' object has no attribute '_repr_svg_'
    [31m---------------------------------------------------------------------------[39m
    [31mAttributeError[39m                            Traceback (most recent call last)
    [36mFile [39m[32m/usr/local/lib/python3.12/site-packages/IPython/core/formatters.py:406[39m, in [36mBaseFormatter.__call__[39m[34m(self, obj)[39m
    [32m    404[39m     method = get_real_method(obj, [38;5;28mself[39m.print_method)
    [32m    405[39m     [38;5;28;01mif[39;00m method [38;5;129;01mis[39;00m [38;5;129;01mnot[39;00m [38;5;28;01mNone[39;00m:
    [32m--> [39m[32m406[39m         [38;5;28;01mreturn[39;00m [43mmethod[49m[43m([49m[43m)[49m
    [32m    407[39m     [38;5;28;01mreturn[39;00m [38;5;28;01mNone[39;00m
    [32m    408[39m [38;5;28;01melse[39;00m:

    [36mCell[39m[36m [39m[32mIn[1][39m[32m, line 3[39m, in [36m_repr_svg_[39m[34m(self)[39m
    [32m      1[39m [38;5;129m@patch_to[39m(Value)
    [32m      2[39m [38;5;28;01mdef[39;00m[38;5;250m [39m[34m_repr_svg_[39m([38;5;28mself[39m:Value): 
    [32m----> [39m[32m3[39m     [38;5;28;01mreturn[39;00m [43mdraw_dot[49m[43m([49m[38;5;28;43mself[39;49m[43m)[49m[43m.[49m[43m_repr_svg_[49m()

    [31mAttributeError[39m: 'Digraph' object has no attribute '_repr_svg_'

    Value(data=-7.0, grad=0.0, _op='+', _prev={Value(data=-3.0, grad=0.0, _op='', _prev=set(), label=''), Value(data=-4.0, grad=0.0, _op='+', _prev={Value(data=-6.0, grad=0.0, _op='*', _prev={Value(data=-3.0, grad=0.0, _op='', _prev=set(), label=''), Value(data=2.0, grad=0.0, _op='', _prev=set(), label='')}, label=''), Value(data=2.0, grad=0.0, _op='', _prev=set(), label='')}, label='')}, label='')

None of them worked

##### ü§ñReplyü§ñ<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

Let me check what methods are available on the Digraph object:

``` python
dot = draw_dot(c)
[m for m in dir(dot) if 'repr' in m or 'svg' in m]
```

Try running this to see what rendering methods graphviz actually has.
That will help us figure out the right approach for solveit.

``` python
dot = draw_dot(c)
[m for m in dir(dot) if 'repr' in m or 'svg' in m]
```

    ['__repr__',
     '_repr_image_jpeg',
     '_repr_image_png',
     '_repr_image_svg_xml',
     '_repr_mimebundle_']

##### ü§ñReplyü§ñ<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

Try this - the method exists but might be returning bytes instead of a
string:

``` python
@patch_to(Value)
def _repr_svg_(self:Value): 
    svg = draw_dot(self)._repr_image_svg_xml()
    return svg.decode('utf-8') if isinstance(svg, bytes) else svg
```

This should handle the conversion properly. Give it a try!

``` python
@patch_to(Value)
def _repr_svg_(self:Value): 
    svg = draw_dot(self)._repr_image_svg_xml()
    return svg.decode('utf-8') if isinstance(svg, bytes) else svg
```

``` python
a = Value(2.0)
b = Value(-3.0)
a*b, a+b
c = a*b+a+b; c
```

    /usr/local/lib/python3.12/site-packages/IPython/core/formatters.py:429: FormatterWarning: text/html formatter returned invalid type <class 'graphviz.graphs.Digraph'> (expected <class 'str'>) for object: Value(data=-7.0, grad=0.0, _op='+', _prev={Value(data=-3.0, grad=0.0, _op='', _prev=set(), label=''), Value(data=-4.0, grad=0.0, _op='+', _prev={Value(data=2.0, grad=0.0, _op='', _prev=set(), label=''), Value(data=-6.0, grad=0.0, _op='*', _prev={Value(data=2.0, grad=0.0, _op='', _prev=set(), label=''), Value(data=-3.0, grad=0.0, _op='', _prev=set(), label='')}, label='')}, label='')}, label='')
      warnings.warn(

![](02_utils_files/figure-commonmark/cell-33-output-2.svg)

Good I would also live to ignore warning here

##### ü§ñReplyü§ñ<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

You can suppress that warning by importing warnings and filtering it:

``` python
import warnings
warnings.filterwarnings('ignore', category=UserWarning, module='IPython.core.formatters')
```

Try adding this at the top of your notebook. That should hide the
FormatterWarning messages.

``` python
c
```

![](02_utils_files/figure-commonmark/cell-34-output-1.svg)
